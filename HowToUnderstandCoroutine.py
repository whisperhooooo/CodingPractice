#协程：协程也是子程序，但执行过程中，子程序内部可中断，然后转而执行别的子程序，在适当的时候在返回来执行
#consumer是一个迭代器
#produce在执行的时候，先启动生成器c.send(None),执行到yield语句然后被挂起，继续从#3开始执行
#然后进入循环，输出Producing 1...
#执行到c.send(1)时，进入到#4 此时n=1,Consuming 1...
#然后r = '200 OK' 又循环至了生成器，被挂起，输出Consumer return 200 OK...
#send方法有一个参数，该参数指定的是上一次被挂起的yield语句的返回值


def consumer():
	r=''
	while True:
		n = yield r#2
		if not n:#4
			return
		print('[CONSUMER] Consuming %s...'%n)
		r = '200 OK'
def produce(c):
	c.send(None)#1
	n = 0 #3
	while n < 5:
		n+=1
		print('[PRODUCER] Producing %s...'%n)
		r = c.send(n)
		print('[PRODUCER] Consumer return %s...'%r)
	c.close()

c = consumer()
produce(c)

# 打印结果如下
# [PRODUCER] Producing 1...
# [CONSUMER] Consuming 1...
# [PRODUCER] Consumer return 200 OK...
# [PRODUCER] Producing 2...
# [CONSUMER] Consuming 2...
# [PRODUCER] Consumer return 200 OK...
# [PRODUCER] Producing 3...
# [CONSUMER] Consuming 3...
# [PRODUCER] Consumer return 200 OK...
# [PRODUCER] Producing 4...
# [CONSUMER] Consuming 4...
# [PRODUCER] Consumer return 200 OK...
# [PRODUCER] Producing 5...
# [CONSUMER] Consuming 5...
# [PRODUCER] Consumer return 200 OK...